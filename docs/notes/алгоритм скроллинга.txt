ЧТо нужно знать о комнате для скороллинга?

1. Графика комнаты - размеры(3х2, 2х2, 1х2 и т.д.). Макс. размер 3х3, 96x90 спрайтов
2. Форма комнаты задается прямоугольниками проходимости. Точку куда перейдет игрок проверям на вхождение в них. Все прямоуголники
заданы в спрайтах а не в пикселах.
3. Положение камеры задается в пределах локации внутри прямоугольника 96х90. Камера ставится на стартовую точку и никак не подстраивается
3. Текстовый движок рисует поверх бека, и оперирует спрайтами бекграунда. Накладывается на комнаты, скроллинг никак не
зависит от текста.

Алгоритм загрузки локации
1. Получаем стартовую точку в координатах комнаты. К примеру это стартовая комната 2х2. Т.к. каждый бек у нас 32х30 по координатам мы определяем:
2. Номер тайлов которые видим.
3. Смещение для тайлов с которых мы вычитываем в ppu
Камеру выставляем в центр, заполняем nametable в зоне видимости камеры по вычисленым смещениям. 
Движение персонажа.
1. Считываем нажатия клавиш
2. При нажатии стрелок считаем новую позицию персонажа
3. Проверяем попадание в прямоугольники. Если попадаем - запускаем анимацию движения
4. Анимация движения оперирует спрайтами бека, нельзя двинуться на полспрайта
5. При движении:
- изменяем скроллинг в PPU 
- подгружаем новую строку или стольец по направлению движения в ppu


Что нужно от движка?
- Данные комнат
Общий алгоритм перемещения игрока и скроллинга:
1. Задаем номер комнаты, номер двери через которую вошел игрок. Аналогично после выбора сложности мы запускаем вход в холл через главную дверь
2. Движок загружает данные о комнате. В частности

	1. Список дверей в комнату. 3 байта на дверь, каждая дверь задает
	- 1 байт - номер комнаты и номер двери в которую дверь ведет. Нижние 3 бита - номер двери, верхние 5 - номер комнаты в локации
	- 2 байта - координаты камеры при входе в комнату через эту дверь.
	2. Список прямоугольников проходимости - каждый 4 байта,
	3. 2 байта - количество тайлов по ширине и высоте
	4. Для каждого тайла окружения 1 байт - индекс в таблице изображений с данными о тайлах
	5. Индекс в таблице палитр о палитре комнаты
	6. Индекс в таблице спрайтов о спрайтах
	Палитра и спрайты для комнаты задаются 1 раз на комнату, 
	
3. Запоминаем номер комнаты. Из данных комнаты читаем позицию камеры.
4. По координатам камеры запускаем загрузку данных для отрисовки
	-1. Функция LoadRoomPalleteAndSprites. По номеру комнаты грузим палитру и спрайты тайлов комнаты.
	0. Функция CalcViewport. Получает позицию игрока в рамках комнаты, возвращает 4 числа - вьюпорт прямоугольника камеры в рамках комнаты
	Вьюпорт храним в данных игрока, обновляем при движении чтоб не пересчитывать.
	1. Запоминаем скроллинг в RAM по текущему вьюпорту. Выставляем правильный адрес в PPU соотвтствующий окну скроллинга, запоминаем его в ppu_addr
	1. Функция LoadTilesForViewport получает номера тайлов, которые мы должны загрузить в PPU исходя из зоны видимости.
	LoadRoomTilesForCamera. Вход - текущая позиция камеры. Выход - 4 тайла попдающих в камеруЮ записываем в данные RAM
	Видимые тайлы - 4 байта в данных игрока в RAM, индексы тайлов для данной комнаты начиная с 1. Если какой-то из тайлов не видим - будет записан 0
	2. Цикл по видимым тайлам от 0 до 3
		1. LoadRoomTile Вход в arg0b храним тип тайла(0 - Upper Left Corner, 1 - Down Left Corner, 2 - Down Right, 3 Upper Left). 
	Если в данных игрока индекс тайла этого типа не 0 - вызываем для него
		2. LoadImageFromTable. Вход - индекс в таблице изображений. Выход arg1w - адрес тайлмапа для изображения в ROM
		Спрайты и палитра уже загружены в LoadRoomPalleteAndSprites
		3. CalcTileDimensions. Она обновляет tilemap_min_x, tilemap_min_y, tilemap_max_x, tilemap_max_y которые задают строки и столбцы тайла 
		4. SetupPPUAddress - в завиимости от типа тайла в arg0b выбираем квадрант вьюпорта в PPU в который пишем кусок тайла
		4. Вызываем load_tilemap. Вход tilemap_min_x, tilemap_min_y, tilemap_max_x, tilemap_max_y, ppu_addr
		Функция должна корректно загрузить кусок тайла в PPU исходя из вьюпорта. Адрес в PPU уже должен быть настроен в SetupPPUAddress
5. Данные загружены, обновляем нажатия клавиш.
6. Если нажаты клавиши направления:
- грузим из данных комнаты прямоугольники проходимости
- проверяем есть ли точка куда собираемся двигаться в них
- если да, запускаем перемещение камеры. Нет - остаемся на месте.
7. Алгоритм перемещения камеры. Вход - arg0b - направление движения(0 - Left, 1 - Up, 2 - Right, 3 Down).
	1. В зависимости от типа движения - высчитываем индексы поменявшихся тайлов. Условно при движении вверх = меняются UL и UR
	2. В завиимости от направления движения изменяем вьюпорт. 
	3. Для каждого поменявшегося тайла вызываем UpdateRoomTile. Вход arg0b - тип тайла(0 - Upper Left Corner, 1 - Down Left Corner, 2 - Down Right, 3 Upper Left)
		- UpdateTIleScrolling - вход - 
		




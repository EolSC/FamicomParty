переключение во второй банк, команда 6, код = 

Адрес палитры - palette_bg_321


Загрузка - в функции sub_BD45

20 байт с маской 3
0E0106010E0007000000000000000000
0E00010F

Тайлы грузим из первого банка
Execute bank command (command - 0), to: 1, from: 0

Основная загрузка - load_tiles_state_1F25D -> load_palettes_to_ram_1F268

1. Проверка sprite_type_306. Загружается из prev_sprite_type_4A9 в load_image_C6D2, линия 3094. prev_sprite_type_4A9 выставляется в SET prev_sprite_type_4A9, #2 в start_game_loop_8571
2. Если тип спрайта - 0, идем в loc_1F2C3, иначе
3. Грузим 0 в sprPalIdx_319.
4. Выбираем палитру get_sprite_palette_ptr_1F2F3
5. Копируем палитру в RAM - copy_sprite_palette_to_ram_1F316
6. Увеличивам sprPalIdx_319 на 1
7. Грузим адрес палитры в get_sprite_palette_ptr_1F2F3 в data_0
8. Увеличиваем адрес data_0 на 4
9 ...

В целом за 4 чтения по 4 байта мы читаем палитру из таблицы




get_sprite_palette_ptr_1F2F3:
1. В ptr_0 кладем адрес SpritePalettes_18079( адрес - 8079)
2. Умножаем на 2 значение в objectIdx_318(палитра для фона?) 0*2 = 0
3. Прибавляем значение из objectIdx_318 к ptr0. Видимо, это смещение для выборки палитры
4. К верхнему байту ptr0 прибавляем #0. Хз зачем, просто говнокод
5. В data_2 читаем данные из ptr0. Это адрес палитры, прочитанной из SpritePalettes_18079 со смещением 0

copy_sprite_palette_to_ram_1F316:
1. Читаем данные из sprPalIdx_319, умножаем на 4
2. Перемещаем полученное значение в Х(для изображений в начле игры - 0)
3. Читаем значение по адресу data_2(адрес палитры со смещенем 0 из get_sprite_palette_ptr_1F2F3) и кладем его в sprite_palette_331. Копируем 4 значения.


Теперь палитра загружена в sprite_palette_331(16 значений). Грузим ее в PPU
upload_tiles_to_ppu_1F32A
1. Если тип спрайта sprite_type_306 - 0, идем в loc_1F33D
2. Записываем 0 в sprite_secondByte_31B
3. Переходим в get_sprite_ptr_1F36D
4. Теперь у нас есть адрес спрайта в data_2 и его длина в sprite_length_30F
5. Переходим в upload_to_ppu_1F6D1, макрос UPLOAD_DATA_TO_PPU_FUNC

get_sprite_ptr_1F36D
1. Помещаем в ptr_0 адрес данных спрайтов в банке(Sprites - $93A1)
2. Умножаем на 2 индекс спрайта в objectIdx_318
3. Составляем адрес спрайта в таблице как ptr_0 + objectIdx_318*2
4. В data_2 читаем данные из ptr_0. В data_2 получаем адрес спрайта с индексом objectIdx_318(93D7 - спрайт Jill)
5. Читаем первый байт спрайта в sprite_length_30F
6. Пишем байт из sprite_secondByte_31B в ptr_0 и умножаем значение на 16

UPLOAD_DATA_TO_PPU_FUNC
1. Пишем 0 в Y, читаем данные из data_2
2. Пишем первый байт спрайта(Для Jlll - 5D) в tilemapWidth_308
3. Смещаем data_2 на 2 байта(видимо, пропускаем размер)
4. Вызываем PPU_WRITE_DATA_FUNC с аргументом tilemapWidth_308
PPU_WRITE_DATA_FUNC
1. В PPU_ADDR выставляем значение из ptr_0(в случае с Jill - 0000)
2. Читаем данные блоками по 16 байт, каждый цикл увеличиваем Х на 1, сдвигаем указатель PPU(ptr_0) на 16 и данные в data_2 на 16

Адрес для тайтла - A1*2 + C558 = C69A
В data_2 - C6D1, последняя запись таблицы, достаем значение byte_C6D1 = $20, кладем в entry_idx_300
Достаем значение из byte_BD1C, кладем в tilemapTypeUnk_30B
Если значение в entry_idx_300 < byte_BD1C[1]($16) - уменьшим Х до 0 и отправим X->A. В противном случае увеличим Х и сравниваем с tilemapTypeUnk_30B
2 = 2, идем дальше - уменьшаем Х до 1 и отправим Х -> A
Добавляем к А = 1 значене 5, т.е. 6 банк , выбираем 0 команду и 9 как банк возврата, затем меняем банки

В целом выглядит как заебистый способ понять в каком банке лежит какая графика

Выбираем в 6м банке спрайт $20, это Copyright_6EAD1


Загрузка тайлмапов sub_ECCC
1. Функция sub_ED7C, вычисляем ppu_unk_byte_309 и tilemap_size_307, оба значения 0.
2. В Х кладем ppu_unk_byte_302, в Y - ppu_unk_byte_303. Оба значения 0 при загрузке начальных изображений.
3. Вызов sub_ED81. В data_2 = 0, в data_3 - $20( X = 0, Y = 0)
4. Вызов sub_ED8F. Каждое значение в ppu_unk_byte_303 увеличивает data_2 на $20. 
5. Вызов sub_EDA2 - добавляем к data_2 значение tilemap_size_307(0 в текущем контексте)
6. В Х кладем  ppu_unk_byte_302(0), в Y - ppu_unk_byte_302(0)
7. В tilemapTypeUnk_30B кладем значение 3
8. В А кладем $20 и вычитаем tilemap_size_307 из него. Полученное значение уходит в tilemapWidth_308
9. В А кладем $1E и вычитаем ppu_unk_byte_309 из него. Полученное значение в tilemapHeight_30A
10 Вызов sub_EDD6 -грузим chunk данных из тайлмапа
11 Загружаем в Х ppu_unk_byte_302(0) и увеличиваем X на 1
12 Загружаем в Y ppu_unk_byte_303(0).
13 Вызываем sub_ED81. В data_2=0, в data_3 - 24( X = 1, Y = 0)
14 Вызываем sub_ED8F. В data_2=0, в data_3 - 24(
15 Загружаем в Х ppu_unk_byte_302(0) и увеличиваем X на 1
16 Загружаем в Y ppu_unk_byte_303(0)
17 В tilemapTypeUnk_30B кладем значение 2
18 В tilemapWidth_308 кладем tilemap_size_307(0)
19. В A кладем $1E и вычитаем ppu_unk_byte_309 из него. Полученное значение в tilemapHeight_30A
20 Вызов sub_EDD6 -грузим chunk данных из тайлмапа. Тут же выходим т.к. tilemapWidth_308 == 0
21 Загружаем в Х ppu_unk_byte_302(0) 
22 Загружаем в Y ppu_unk_byte_303(0)
23. Увеличиваем Y
24. Вызываем sub_EDB1. В data_2=0, в data_3 - 28( X = 0, Y = 1)
25  Вызываем sub_ED8F. В data_2=0, в data_3 - 28
26 Загружаем в Х ppu_unk_byte_302(0) 
27 Загружаем в Y ppu_unk_byte_303(0)
38 Увеличиваем Y
39. В tilemapTypeUnk_30B кладем значение 1
40. В А кладем $20 и вычитаем tilemap_size_307 из него. Полученное значение уходит в tilemapWidth_308
41. В tilemapHeight_30A кладем ppu_unk_byte_309(0)
42 Вызываем sub_EDD6. Тут же выходим т.к. tilemapHeight_30A равен 0
43. 26 Загружаем в Х ppu_unk_byte_302(0) 
44 Загружаем в Y ppu_unk_byte_303(0)
45 Увеличиваем X и Y
46 Вызываем sub_EDB1. В data_2=0, в data_3 - 44( X = 1, Y = 1)
47 Загружаем в Х ppu_unk_byte_302(0) Увеличиваем Х на 1
48 Загружаем в Y ppu_unk_byte_303(0) увеличиваем Y на 1
49. В tilemapTypeUnk_30B кладем значение 0
50. В tilemapWidth_308 кладем tilemap_size_307(0)
51. В tilemapHeight_30A кладем ppu_unk_byte_309(0)
52. Вызываем sub_EDD6. Тут же выходим т.к. tilemapHeight_30A равен 0


sub_EE72

1. Выполняем sub_ED7C. Для стартовой картинки ppu_unk_byte_309 и tilemap_size_307, оба значения 0.
2. Делим на 4 ppu_unk_byte_309 и tilemap_size_307 получам 0 и там и там для стартовой картинки
3. Загружаем в А #8, вычитаем из него tilemap_size_307. Результат пишем в tilemapWidth_308
4. Загружаем в А #8, вычитаем из него ppu_unk_byte_309. Результат пишем в tilemapHeight_30A
5. В X кладем tilemap_size_307
6. Кладем ppu_unk_byte_309 в стек
loc_EE9A:
7. Кладем Х(tilemap_size_307) в стек
tilemap_size_307 и ppu_unk_byte_309 похоже на смещение из-за скроллинга в байтах
8. Кладем entry_idx_300 в tilemapData_4C, значение - $A1
9. Грузим в room_pos_x_4D значение из Х(ppu_unk_byte_302)- 0
10. Грузим в room_pos_y_4E значение из Y(ppu_unk_byte_303) - 0
11. Грузим в tilemap_line_idx_4F значение из ppu_unk_byte_309- 0
12 Грузим в mapLineSize_50 значение из tilemap_size_307 - 0
13 Грузим в tilemap_line_size_51 значение $08
14 Грузим в mapLineWidth_52 значение из tilemapWidth_308 - 8
15 Грузим в mapLineHeight_53 значение #1
16 Вызываем tilemap_read_next_chunk_F472
17 В Y кладем 0
18 В byte_4 кладем данные с оффсетом Х, прочитанные из tilemapData_4C со смещение Y
19 Увеличиваем X и Y
20 Пока Y < tilemapWidth_308 читаем данные в byte_4 в цикле
21 Досттаем из стека tilemap_size_307
22 Добавляем к А число 8
23 Перемещаем А в Х - 8
24 Увеличиваем ppu_unk_byte_309 на 1
25 Уменьшаем на 1 tilemapHeight_30A
26 Если tilemapHeight_30A не равно 0 - возвращаемся в loc_EE9A
27 Достаем из стека ppu_unk_byte_309 -0
28. Если ppu_scroll_x_304 не равен 0 - рассчитываем скролл. Иначе - идем на loc_EF71
... 
loc_EF71
30 Если ppu_scroll_y_305 не равен 0 - рассчитываем скролл. Иначе - идем на выход locret_F09C

Получаем 






sub_ED7C
1. Грузим данные из ppu_scroll_y_305 и делим на 8. В начале это значение $00, копируется 0 из ppu_prev_scroll_y_unk_4A8, результат - 0, кладем в ppu_unk_byte_309.
2. Грзим данные из ppu_scroll_x_304 и делим на 8. В начале это 0, результат 0, кладем в tilemap_size_307.

sub_ED81
1. Кладем Y в А(ppu_unk_byte_303 при вызове из функции загрузки тайлмапов)
2. Выполняем AND #1, маска младшего разряда, нечетность 
3. Если в младшем разряде остался 0(число четное) - кладем в data_2 - 0, в data_3 - $20, иначе data_2 = 0, data_3 - $28
4. Кладем Х в А(ppu_unk_byte_302 при вызове из функции загрузки тайлмапов)
5. Выполняем AND #1, маска младшего разряда
6. Если в младшем разряде остался 0(число четное) - идем на выход. Иначе, к data_3 добавим 4.

Получается схема data_2 = 0
ppu_unk_byte_303 и ppu_unk_byte_302 - четные -  data_3 = $20(32)
ppu_unk_byte_303 - нечетное, ppu_unk_byte_302 - четное - data_3 = $28(40)
ppu_unk_byte_303 и ppu_unk_byte_302 - нечетные -  data_3 = $2C(44)

sub_ED8F
1. кладем Y в стек(ppu_unk_byte_303)
2. Грузим в Y ppu_unk_byte_309(0)
3. Если в Y - 0: вынимаем Y из стека и уходим. Иначе, увеличиваем data_2 на $20 в цикле по Y. Тут шаг по 32 байта на одно значение Y, через макрос ADD_WORD_TO_WORD_IMM

sub_EDD6:
1. Если tilemapHeight_30A = 0 - на выход
2. Если tilemapWidth_308 = 0 - на выход
3. Кладем в стек ppu_unk_byte_309, потом tilemap_size_307
4. Читаем тип спрайта из tilemapTypeUnk_30B. Если прочитали значение 3 - начинаем читать тайлмап(start_read_tilemap_EE1C)
5. Если тип спрайта равн 2 - зануляем tilemap_size_307 и идем на start_read_tilemap_EE1C
5. Если тип спрайта равн 1 - зануляем ppu_unk_byte_309 и идем на start_read_tilemap_EE1C
start_read_tilemap_EE1C:
6. Кладем в tilemapData_4C значение из entry_idx_300. Это значение $A1 для стартового изображения(индекс изображения).
7. Грузим в room_pos_x_4D значение из Х(ppu_unk_byte_302)- 0
8. Грузим в room_pos_y_4E значение из Y(ppu_unk_byte_303) - 0
9. Грузим в tilemap_line_idx_4F значение из ppu_unk_byte_309- 0
10 Грузим в mapLineSize_50 значение из tilemap_size_307 - 0
11 Грузим в tilemap_line_size_51 значение $20
12 Грузим в mapLineWidth_52 значение из tilemapWidth_308  - $20
13 Грузим в mapLineHeight_53 значение #1
14 Читаем блок данных тайла в tilemap_read_next_chunk_F472
15 Пишем в PPU_ADDR - data_3($20), потом data_2($0)
16. Сохраняем Y в стек
17. Кладем в Y значение 0. Читаем данные из tilemapData_4C 
18.  В цикле по Y грузим chunk размером в tilemapWidth_308 в PPU
19. Восстанавливаем Y
20. Увеличиваем ppu_unk_byte_309
21. Вызываем sub_F194 - увеличиваем data_2(адрес в ppu) на $20
22. Уменьшаем tilemapHeight_30A
23. Если tilemapHeight_30A > 0 - возвращаемся в цикл start_read_tilemap_EE1C
24. Достаем из стека tilemap_size_307 и ppu_unk_byte_309


tilemap_read_next_chunk_F472:
1. Кладем Х и Y в стек(ppu_unk_byte_302 и ppu_unk_byte_303)
2. Кладем в стек ptr_0, ptr_1, data_2, data_3, entry_idx_300
3. Получаем указатель на данные из таблицы tilemap_entries_C000 по смещению entry_idx_300($A1 для стартового изображения) Получаем смещение $С142(С000 + $142)
4. Читаем адрес тайлмапа($C554), получаем tilemap_entry_C554
5. Читаем tilemapEntry. 
tilemap_entry_C554:
	.byte 	1,   1
	.byte $11, $1A
6. 2 байта($1, $1) кладем в tilemaps_horiz_count_311 и в tilemaps_vert_count_312
7. Обнуляем A.
8. Грузим в Y значение из room_pos_y_4E
9. Если в Y ненулевое значение скроллинга - в цикле по Y увеличиваем А на tilemaps_horiz_count_311
10 Прибавляем к A значение из room_pos_x_4D
11 Умножаем А на 2 и перемещаем в Y
12 Прибавляем к Y значение 2
Таким образом мы выше вычисляем(шаги 6-12 в  tilemap_read_next_chunk_F472) с какого смещения в tilemap_entry мы читаем данные. 
Тайлмап после размеров в первых 2х байтах содержит записи вида {банк, entry_idx_300} для того чтобы подгрузить правильные данные о тайлах
При этом независимо от номера банка после переключения используется команда 0

13 Читаем индекс банка и entry_idx_300. Банк - $11, entry_idx_300 = $1A
14. Читаем тайлмап из  tilemaps/bank_11.asm(LOAD_TILEMAP_CHUNK_IN_RAM)
15. Возвращаемся из банка, в обратном порядке восстанавливаем  entry_idx_300, data_3, data_2, ptr_1, ptr_0, X, Y.

LOAD_TILEMAP_CHUNK_IN_RAM:
1. Читаем данные из off_11805B со смещением entry_idx_300 = $1A. Получаем смещение E891, кладем адрес в ptr_0
2. Если tilemap_line_size_51 == $20 - значит размер строки тайлмапа у нас 16. Возможны значения 8 и 16
3. Если значение 8 - к ptr_0 добавим число $3C0(960)
4. В Y кладем tilemap_line_idx_4F. Если значение равно 0 - вы полняем addOffset_F8F6. Иначе в цикле по Y добавляем к ptr_0 размер линии тайлов(tilemap_line_size_51)
addOffset_F8F6:
5. Добавляем к ptr_0 значение mapLineSize_50(0)
6. В data_2 - mapLineWidth_52($20), в data_3 - mapLineHeight_53(1)
7. Зануляем X и Y
write_tilemap_line_F90F:
8. Читаем значение из ptr_0 и смещением Y в tilemapData_4C со смещением X.
9. Добавляем к ptr_0 значение data_3
10. Увеличиваем Х. Если Х меньше data_2($20) - продолжаем чтение.
Таким образом мы читаем chunk данных из тайлмапа размером в mapLineWidth_52 со смещением mapLineHeight_53*mapLineWidth_52





Загрузка палитры:
ppu_upset_data_FDCB

1. Проверяем значение по адресу ppu_data_70. Если там 0 - идем на выход. Для палитр будет $1, $20, $3F, $0

2. Читаем следующий байт в А с маской $80 (старший бит).  Если там ненулевое значение - добавляем флаг PPU_SHOW_BGR к ppu_ctrl_31F и кладем ppu_ctrl_31F в PPU_CTRL
Дл палитр - старший байт равен 0
3.  Выключаем в ppu_ctrl_31F третий бит(PPU_SHOW_LEFT_SPR) через AND_BYTE ppu_ctrl_31F, #$FB 
4. Читаем байт по адресу ppu_data_70, 1 и грузим с маской 7F(младшие биты). Полученное значение идет в ppu_fld1_y_6E
5. Загружаем следующий 2 байта и кладем их в PPU_ADDR. Для палитр это 3F, $0
6. Читаем ppu_fld1_y_6E байт со смещения ppu_data_70+4 и грузим их в PPU




sub_BD45
1. Копируем первый байт из палитры  palette_bg_321(для первого изображения это 3E) в байт по смещению palette_bg_321+10. Видимо, это цвет фона

3E0116213E0027300000000000000000
3E30110F0000000000000000000000

3E0116213E0027300000000000000000
3E30110F000000000000000000000000
00
